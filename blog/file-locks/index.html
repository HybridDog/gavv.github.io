<!DOCTYPE html>

  <html lang="en-US">
    <head>
      <meta charset="UTF-8"/>

      <meta name="description" content="Table of contents
 Introduction Advisory locking  Common features Differing features File descriptors and i-nodes BSD locks (flock) POSIX record locks (fcntl) lockf function Open file description locks (fcntl) Emulating Open file description locks Command line tools  Mandatory locking  Introduction File locking is a mutual-exclusion mechanism for files. Linux supports two major kinds of file locks:
 advisory locks mandatory locks  Below we discuss all lock types available in POSIX and Linux and provide usage examples."/>
      <meta name="author" content="Victor Gaydov"/>

      <meta property="og:url" content="http://gavv.github.io/blog/file-locks/"/>
      <meta property="og:title" content="
  
    File locking in Linux
  
"/>
      <meta property="og:description" content="Table of contents
 Introduction Advisory locking  Common features Differing features File descriptors and i-nodes BSD locks (flock) POSIX record locks (fcntl) lockf function Open file description locks (fcntl) Emulating Open file description locks Command line tools  Mandatory locking  Introduction File locking is a mutual-exclusion mechanism for files. Linux supports two major kinds of file locks:
 advisory locks mandatory locks  Below we discuss all lock types available in POSIX and Linux and provide usage examples."/>
      <meta property="og:site_name" content="Victor Gaydov"/>

      <link rel="canonical" href="http://gavv.github.io/blog/file-locks/"/>

      <title>
  
    File locking in Linux
  
</title>

      <meta name="viewport" content="initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="/css/main.css"/>
<link rel="stylesheet" href="/css/prism.css"/>
<link rel="stylesheet" href="/css/lightbox.min.css"/>

<link rel="shortcut icon" href="/images/favicon.ico">

<link rel="stylesheet"
      href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.css">

<link rel="stylesheet"
      href="//fonts.googleapis.com/css?family=Open+Sans|Lustria|Roboto+Mono">

<script src="/js/lightbox-plus-jquery.min.js">
</script>

<script>
    lightbox.option({
      'wrapAround': true,
      'resizeDuration': 0,
      'fadeDuration': 0,
      'imageFadeDuration': 0,
    })
</script>

<script src="/js/prism.js">
</script>

<script>
if (screen && screen.width < 480) {
  document.write('<script src="/js/hyphenator-loader.js"><\/script>');
}
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-93472390-1', 'auto');
  ga('send', 'pageview');
</script>

    </head>
    <body>
      <div id="toplevel">
        <header id="header" class="no-print">
  <div id="caption">
    Victor Gaydov
  </div>
  <div id="menu">
    <div>
      <div>
        <a href="/about/">About</a>
      </div>
    </div>
    <div>
      <div>
        <a href="/projects/">Projects</a>
      </div>
    </div>
    <div>
      <div>
        <a href="/blog/">Blog</a>
      </div>
    </div>
    <div id="header-buttons">
      <div>
        <a href="https://twitter.com/gavv42" class="image-button">
          <i class="fa fa-twitter"></i>
        </a>
        <a href="/index.xml" class="image-button">
          <i class="rss-button fa fa-rss"></i>
        </a>
      </div>
    </div>
  </div>
</header>

        
  <section role="main">
    <article>
      
        
  <header class="post-header">
    <h1 class="post-title">
      
        File locking in Linux
      
    </h1>
    <div class="post-time">
      <time datetime="2016-07-29">
        29 Jul 2016
      </time>
    </div>
    <div class="post-tags">
      
      <div class="post-tag">
        <a href="/tags/linux">linux</a>
      </div>
      
      <div class="post-tag">
        <a href="/tags/posix">posix</a>
      </div>
      
      <div class="post-tag">
        <a href="/tags/ipc">ipc</a>
      </div>
      
    </div>
  </header>


      
      <section>
        

<p><strong>Table of contents</strong></p>

<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#advisory-locking">Advisory locking</a>

<ul>
<li><a href="#common-features">Common features</a></li>
<li><a href="#differing-features">Differing features</a></li>
<li><a href="#file-descriptors-and-i-nodes">File descriptors and i-nodes</a></li>
<li><a href="#bsd-locks-flock">BSD locks (flock)</a></li>
<li><a href="#posix-record-locks-fcntl">POSIX record locks (fcntl)</a></li>
<li><a href="#lockf-function">lockf function</a></li>
<li><a href="#open-file-description-locks-fcntl">Open file description locks (fcntl)</a></li>
<li><a href="#emulating-open-file-description-locks">Emulating Open file description locks</a></li>
<li><a href="#command-line-tools">Command line tools</a></li>
</ul></li>
<li><a href="#mandatory-locking">Mandatory locking</a></li>
</ul>

<hr />

<h2 id="introduction">Introduction</h2>

<p><a href="https://en.wikipedia.org/wiki/File_locking">File locking</a> is a mutual-exclusion mechanism for files. Linux supports two major kinds of file locks:</p>

<ul>
<li>advisory locks</li>
<li>mandatory locks</li>
</ul>

<p>Below we discuss all lock types available in POSIX and Linux and provide usage examples.</p>

<hr />

<h2 id="advisory-locking">Advisory locking</h2>

<p>Traditionally, locks are <a href="http://unix.stackexchange.com/questions/147392/what-is-advisory-locking-on-files-that-unix-systems-typically-employs">advisory</a> in Unix. They work only when a process explicitly acquires and releases locks, and are ignored if a process is not aware of locks.</p>

<p>There are several types of advisory locks available in Linux:</p>

<ul>
<li>BSD locks (flock)</li>
<li>POSIX record locks (fcntl, lockf)</li>
<li>Open file description locks (fcntl)</li>
</ul>

<p>All locks except the <code>lockf</code> function are <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">reader-writer locks</a>, i.e. support exclusive and shared modes.</p>

<p>Note that <a href="http://man7.org/linux/man-pages/man3/flockfile.3.html"><code>flockfile</code></a> and friends have nothing to do with the file locks. They manage internal mutex of the <code>FILE</code> object from stdio.</p>

<p>Reference:</p>

<ul>
<li><a href="https://www.gnu.org/software/libc/manual/html_node/File-Locks.html">File Locks</a>, GNU libc manual</li>
<li><a href="https://www.gnu.org/software/libc/manual/html_node/Open-File-Description-Locks.html">Open File Description Locks</a>, GNU libc manual</li>
<li><a href="https://lwn.net/Articles/586904/">File-private POSIX locks</a>, an LWN article about the predecessor of open file description locks</li>
</ul>

<h3 id="common-features">Common features</h3>

<p>The following features are common for locks of all types:</p>

<ul>
<li>All locks support blocking and non-blocking operations.</li>
<li>Locks are allowed only on files, but not directories.</li>
<li>Locks are automatically removed when the process exits or terminates. It&rsquo;s guaranteed that if a lock is acquired, the process acquiring the lock is still alive.</li>
</ul>

<h3 id="differing-features">Differing features</h3>

<p>This table summarizes the difference between the lock types. A more detailed description and usage examples are provided below.</p>

<table>
 <tr>
  <th></th>
  <th>BSD locks</th>
  <th>lockf function</th>
  <th>POSIX record locks</th>
  <th>Open file description locks</th>
 </tr>
 <tr>
  <th>Portability</th>
  <td>widely available</td>
  <td>POSIX (XSI)</td>
  <td>POSIX (base standard)</td>
  <td>Linux 3.15+</td>
 </tr>
 <tr>
  <th>Associated with</th>
  <td>File object</td>
  <td>[i-node, pid] pair</td>
  <td>[i-node, pid] pair</td>
  <td>File object</td>
 </tr>
 <tr>
  <th>Applying to byte range</th>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
 </tr>
 <tr>
  <th>Support exclusive and shared modes</th>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>yes</td>
 </tr>
 <tr>
  <th>Atomic mode switch</th>
  <td>no</td>
  <td>-</td>
  <td>yes</td>
  <td>yes</td>
 </tr>
 <tr>
  <th>Works on NFS (Linux)</th>
  <td>Linux 2.6.12+</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
 </tr>
</table>

<h3 id="file-descriptors-and-i-nodes">File descriptors and i-nodes</h3>

<p>A <a href="https://en.wikipedia.org/wiki/File_descriptor"><em>file descriptor</em></a> is an index in the per-process file descriptor table (in the left of the picture). Each file descriptor table entry contains a reference to a <em>file object</em>, stored in the file table (in the middle of the picture). Each file object contains a reference to an <a href="https://en.wikipedia.org/wiki/Inode">i-node</a>, stored in the i-node table (in the right of the picture).</p>

<p><img src="/blog/file-locks/tables.png" width="500px"/></p>

<p>A file descriptor is just a number that is used to refer a file object from the user space. A file object represents an opened file. It contains things likes current read/write offset, non-blocking flag and other non-persistent state. An i-node represents a filesystem object. It contains things like file meta-information (e.g. owner and permissions) and references to data blocks.</p>

<p>File descriptors created by several <code>open()</code> calls for the same file path point to different file objects, but these file objects point to the same i-node. Duplicated file descriptors created by <code>dup2()</code> or <code>fork()</code> point to the same file object.</p>

<p>A BSD lock and an Open file description lock is associated with a file object, while a POSIX record lock is associated with an <code>[i-node, pid]</code> pair. We&rsquo;ll discuss it below.</p>

<h3 id="bsd-locks-flock">BSD locks (flock)</h3>

<p>The simplest and most common file locks are provided by <a href="http://man7.org/linux/man-pages/man2/flock.2.html"><code>flock(2)</code></a>.</p>

<p>Features:</p>

<ul>
<li>not specified in POSIX, but widely available on various Unix systems</li>
<li>always lock the entire file</li>
<li>associated with a file object</li>
<li>do not guarantee atomic switch between the locking modes (exclusive and shared)</li>
<li>up to Linux 2.6.11, didn&rsquo;t work on NFS; since Linux 2.6.12, flock() locks on NFS are emulated using fcntl() POSIX record byte-range locks on the entire file (unless the emulation is disabled in the NFS mount options)</li>
</ul>

<p>These locks are associated with a file object, i.e.:</p>

<ul>
<li>duplicated file descriptors, e.g. created using <code>dup2</code> or <code>fork</code>, refer to the same lock</li>
<li>distinct file descriptors, e.g. created using two <code>open</code> calls (even for the same file), refer to different locks</li>
</ul>

<p>This is a big advantage over the POSIX record locks (see next section).</p>

<p>However, <code>flock()</code> doesn&rsquo;t guarantee atomic mode switch. From the man page:</p>

<blockquote>
<p>Converting a lock (shared to exclusive, or vice versa) is not
guaranteed to be atomic: the existing lock is first removed, and then
a new lock is established.  Between these two steps, a pending lock
request by another process may be granted, with the result that the
conversion either blocks, or fails if LOCK_NB was specified.  (This
is the original BSD behaviour, and occurs on many other
implementations.)</p>
</blockquote>

<p>This problem is solved by other types of locks.</p>

<p>Usage example:</p>

<pre><code class="language-c">#include &lt;sys/file.h&gt;

// acquire shared lock
if (flock(fd, LOCK_SH) == -1) {
    exit(1);
}

// non-atomically upgrade to exclusive lock
// do it in non-blocking mode, i.e. fail if can't upgrade immediately
if (flock(fd, LOCK_EX | LOCK_NB) == -1) {
    exit(1);
}

// release lock
// lock is also released automatically when close() is called or process exits
if (flock(fd, LOCK_UN) == -1) {
    exit(1);
}
</code></pre>

<h3 id="posix-record-locks-fcntl">POSIX record locks (fcntl)</h3>

<p>POSIX record locks, also known as process-associated locks, are provided by <a href="http://man7.org/linux/man-pages/man2/fcntl.2.html"><code>fcntl(2)</code></a>, see &ldquo;Advisory record locking&rdquo; section in the man page.</p>

<p>Features:</p>

<ul>
<li><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fcntl.html">specified</a> in POSIX (base standard)</li>
<li>can be applied to a byte range</li>
<li>associated with an <code>[i-node, pid]</code> pair instead of a file object</li>
<li>guarantee atomic switch between the locking modes (exclusive and shared)</li>
<li>work on NFS (on Linux)</li>
</ul>

<p>These locks are associated with an <code>[i-node, pid]</code> pair, which means:</p>

<ul>
<li>all file descriptors opened by the same process for the same file refer to the same lock (even distinct file descriptors, e.g. created using two <code>open()</code> calls)</li>
</ul>

<p>Therefore, all process&rsquo; threads always share the same lock for the same file. In particular:</p>

<ul>
<li><p>the lock acquired through some file descriptor by some thread may be released through another file descriptor by another thread;</p></li>

<li><p>when any thread calls <code>close()</code> on any descriptor referring to given file, the lock is released for the whole process, even if there are other opened descriptors referring this file.</p></li>
</ul>

<p>This behavior makes it inconvenient to use POSIX record locks in two scenarios:</p>

<ul>
<li><p>when you want to synchronize threads as well as processes because all threads always share the same lock</p></li>

<li><p>when you&rsquo;re writing a library, because you don&rsquo;t control the whole application and can&rsquo;t prevent it from opening and closing independent file descriptors for the file you&rsquo;re locking in the library</p></li>
</ul>

<p>These problems are solved by the Open file description locks.</p>

<p>Usage example:</p>

<pre><code class="language-c">#include &lt;fcntl.h&gt;

struct flock fl;
memset(&amp;fl, 0, sizeof(fl));

// lock in shared mode
fl.l_type = F_RDLCK;

// lock entire file
fl.l_whence = SEEK_SET; // offset base is start of the file
fl.l_start = 0;         // starting offset is zero
fl.l_len = 0;           // len is zero, which is a special value representing end
                        // of file (no matter how large the file grows in future)

// F_SETLKW specifies blocking mode
if (fcntl(fd, F_SETLKW, &amp;fl) == -1) {
    exit(1);
}

// atomically upgrade shared lock to exclusive lock, but only
// for bytes in range [10; 15)
//
// after this call, the process will hold three lock regions:
//  [0; 10)        - shared lock
//  [10; 15)       - exclusive lock
//  [15; SEEK_END) - shared lock
fl.l_type = F_WRLCK;
fl.l_start = 10;
fl.l_len = 5;

// F_SETLKW specifies non-blocking mode
if (fcntl(fd, F_SETLK, &amp;fl) == -1) {
    exit(1);
}

// release lock for bytes in range [10; 15)
fl.l_type = F_UNLCK;

if (fcntl(fd, F_SETLK, &amp;fl) == -1) {
    exit(1);
}

// close file and release locks for all regions
// remember that locks are released when process calls close()
// on any descriptor for a lock file
close(fd);
</code></pre>

<h3 id="lockf-function">lockf function</h3>

<p><a href="http://man7.org/linux/man-pages/man3/lockf.3.html"><code>lockf(3)</code></a> function is a simplified version of POSIX record locks.</p>

<p>Features:</p>

<ul>
<li><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/lockf.html">specified</a> in POSIX (XSI)</li>
<li>can be applied to a byte range (optionally automatically expanding when data is appended in future)</li>
<li>associated with an <code>[i-node, pid]</code> pair instead of a file object</li>
<li>supports only exclusive locks</li>
<li>works on NFS (on Linux)</li>
</ul>

<p>Since <code>lockf</code> locks are associated with an <code>[i-node, pid]</code> pair, they have the same problems as POSIX record locks described above.</p>

<p>The interaction between <code>lockf</code> and other types of locks is not specified by POSIX. On Linux, <code>lockf</code> is <a href="https://github.com/lattera/glibc/blob/master/io/lockf.c">just a wrapper</a> for POSIX record locks.</p>

<p>Usage example:</p>

<pre><code class="language-c">#include &lt;unistd.h&gt;

// set current position to byte 10
if (lseek(fd, 10, SEEK_SET) == -1) {
    exit(1);
}

// acquire exclusive lock for bytes in range [10; 15)
// F_LOCK specifies blocking mode
if (lockf(fd, F_LOCK, 5) == -1) {
    exit(1);
}

// release lock for bytes in range [10; 15)
if (lockf(fd, F_ULOCK, 5) == -1) {
    exit(1);
}
</code></pre>

<h3 id="open-file-description-locks-fcntl">Open file description locks (fcntl)</h3>

<p>Open file description locks are Linux-specific and combine advantages of the BSD locks and POSIX record locks. They are provided by <a href="http://man7.org/linux/man-pages/man2/fcntl.2.html"><code>fcntl(2)</code></a>, see &ldquo;Open file description locks (non-POSIX)&rdquo; section in the man page.</p>

<p>Features:</p>

<ul>
<li>Linux-specific, not specified in POSIX</li>
<li>can be applied to a byte range</li>
<li>associated with a file object</li>
<li>guarantee atomic switch between the locking modes (exclusive and shared)</li>
<li>work on NFS (on Linux)</li>
</ul>

<p>These locks are available since the 3.15 kernel.</p>

<p>The API is the same as for POSIX record locks (see above). It uses <code>struct flock</code> too. The only difference is in <code>fcntl</code> command names:</p>

<ul>
<li><code>F_OFD_SETLK</code> instead of <code>F_SETLK</code></li>
<li><code>F_OFD_SETLKW</code> instead of <code>F_SETLKW</code></li>
<li><code>F_OFD_GETLK</code> instead of <code>F_GETLK</code></li>
</ul>

<h3 id="emulating-open-file-description-locks">Emulating Open file description locks</h3>

<p>What do we have for multithreading and atomicity so far?</p>

<ul>
<li>BSD locks allow thread synchronization but don&rsquo;t allow atomic mode switch.</li>
<li>POSIX record locks don&rsquo;t allow thread synchronization but allow atomic mode switch.</li>
<li>Open file description locks allow both but are available only on recent Linux kernels.</li>
</ul>

<p>If you need both features but can&rsquo;t use Open file description locks (e.g. you&rsquo;re using some embedded system with an outdated Linux kernel), you can <em>emulate</em> them on top of the POSIX record locks.</p>

<p>Here is one possible approach:</p>

<ul>
<li><p>Implement your own API for file locks. Ensure that all threads always use this API instead of using <code>fcntl()</code> directly. Ensure that threads never open and close lock-files directly.</p></li>

<li><p>In the API, implement a process-wide singleton (shared by all threads) holding all currently acquired locks.</p></li>

<li><p>Associate two additional objects with every acquired lock:</p>

<ul>
<li>a counter</li>
<li>an RW-mutex, e.g. <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_rwlock_destroy.html"><code>pthread_rwlock</code></a></li>
</ul></li>
</ul>

<p>Now, you can implement lock operations as following:</p>

<ul>
<li><p><em>Acquiring lock</em></p>

<ul>
<li>First, acquire the RW-mutex. If the user requested the shared mode, acquire a read lock. If the user requested the exclusive mode, acquire a write lock.</li>
<li>Check the counter. If it&rsquo;s zero, also acquire the file lock using <code>fcntl()</code>.</li>
<li>Increment the counter.</li>
</ul></li>

<li><p><em>Releasing lock</em></p>

<ul>
<li>Decrement the counter.</li>
<li>If the counter becomes zero, release the file lock using <code>fcntl()</code>.</li>
<li>Release the RW-mutex.</li>
</ul></li>
</ul>

<p>This approach makes possible both thread and process synchronization.</p>

<h3 id="command-line-tools">Command line tools</h3>

<p>The following tools may be used to acquire and release locks from command line:</p>

<ul>
<li><p><a href="http://man7.org/linux/man-pages/man1/flock.1.html"><code>flock</code></a></p>

<p>Provided by <code>util-linux</code> package. Uses <code>flock()</code>.</p></li>

<li><p><a href="http://linuxcommand.org/man_pages/lockfile1.html"><code>lockfile</code></a></p>

<p>Provided by <code>procmail</code> package. Uses <code>flock()</code>, <code>lockf()</code>, or <code>fcntl()</code> depending on what&rsquo;s available on the system.</p></li>
</ul>

<hr />

<h2 id="mandatory-locking">Mandatory locking</h2>

<p>Linux has limited support for <a href="https://www.kernel.org/doc/Documentation/filesystems/mandatory-locking.txt">mandatory file locking</a>. See the &ldquo;Mandatory locking&rdquo; section in the <a href="http://man7.org/linux/man-pages/man2/fcntl.2.html"><code>fcntl(2)</code></a> man page.</p>

<p>A mandatory lock is activated for a file when all of these conditions are met:</p>

<ul>
<li>The partition was mounted with the <code>mand</code> option.</li>
<li>The set-group-ID bit is on and group-execute bit is off for the file.</li>
<li>A POSIX record lock is acquired.</li>
</ul>

<p>Note that the <a href="https://en.wikipedia.org/wiki/Setuid">set-group-ID</a> bit has its regular meaning of elevating privileges when the group-execute bit is on and a special meaning of enabling mandatory locking when the group-execute bit is off.</p>

<p>When a mandatory lock is activated, it affects regular system calls on the file:</p>

<ul>
<li><p>When an exclusive or shared lock is acquired, all system calls that <em>modify</em> the file (e.g. <code>open()</code> and <code>truncate()</code>) are blocked until the lock is released.</p></li>

<li><p>When an exclusive lock is acquired, all system calls that <em>read</em> from the file (e.g. <code>read()</code>) are blocked until the lock is released.</p></li>
</ul>

<p>However, the documentation mentions that current implementation is not reliable, in particular:</p>

<ul>
<li>races are possible when locks are acquired concurrently with <code>read()</code> or <code>write()</code></li>
<li>races are possible when using <code>mmap()</code></li>
</ul>

<p>Since mandatory locks are not allowed for directories and are ignored by <code>unlink()</code> and <code>rename()</code> calls, you can&rsquo;t prevent file deletion or renaming using these locks.</p>

<p>Below you can find a usage example of mandatory locking.</p>

<p><code>fcntl_lock.c</code>:</p>

<pre><code class="language-c">#include &lt;sys/fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char **argv) {
    if (argc != 2) {
        fprintf(stderr, &quot;usage: %s file\n&quot;, argv[0]);
        exit(1);
    }

    int fd = open(argv[1], O_RDWR);
    if (fd == -1) {
        perror(&quot;open&quot;);
        exit(1);
    }

    struct flock fl = {};
    fl.l_type = F_WRLCK;
    fl.l_whence = SEEK_SET;
    fl.l_start = 0;
    fl.l_len = 0;

    if (fcntl(fd, F_SETLKW, &amp;fl) == -1) {  
        perror(&quot;fcntl&quot;);
        exit(1);
    }

    pause();
    exit(0);
}
</code></pre>

<p>Build <code>fcntl_lock</code>:</p>

<pre><code>$ gcc -o fcntl_lock fcntl_lock.c
</code></pre>

<p>Mount the partition and create a file with the mandatory locking enabled:</p>

<pre><code>$ mkdir dir
$ mount -t tmpfs -o mand,size=1m tmpfs ./dir
$ echo hello &gt; dir/lockfile
$ chmod g+s,g-x dir/lockfile
</code></pre>

<p>Acquire a lock in the first terminal:</p>

<pre><code>$ ./fcntl_lock dir/lockfile
(wait for a while)
^C
</code></pre>

<p>Try to read the file in the second terminal:</p>

<pre><code>$ cat dir/lockfile
(hangs until ^C is pressed in the first terminal)
hello
</code></pre>

      </section>
    </article>
  </section>
  
    
  <footer id="footer">
    <script>
      $('h2, h3, h4').each(function() {
        var id = $(this).attr('id');
        $(this).prepend(
          '<a class="anchor" href="#' + id +'"><i class="fa fa-paragraph"></i></a>'
        );
      })
    </script>

    <div id="disqus_thread" class="no-print"></div>
    <script>
    (function() {
        var d = document, s = d.createElement('script');
        s.src = '//gavv.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Enable JavaScript to view the
        <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
    </noscript>
  </footer>


  

      </div>
    </body>
  </html>

