<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on Victor Gaydov</title>
    <link>http://gavv.github.io/tags/linux/index.xml</link>
    <description>Recent content in Linux on Victor Gaydov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://gavv.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Ephemeral ports and SO_REUSEADDR</title>
      <link>http://gavv.github.io/blog/ephemeral-port-reuse/</link>
      <pubDate>Sun, 03 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>http://gavv.github.io/blog/ephemeral-port-reuse/</guid>
      <description>Ephemeral ports The ephemeral port range is a range of ports used by the kernel when the user wants the socket to be bound to a random unused port.
In particular, bind, listen, connect, and sendto may automatically allocate an ephemeral port for AF_INET and AF_INET6 sockets. This behavior is described in the ip_local_port_range section of the ip(7) man page.
This feature is not specified in POSIX but is available in many operating systems that implement BSD sockets, including Linux.</description>
    </item>
    
    <item>
      <title>PulseAudio under the hood</title>
      <link>http://gavv.github.io/blog/pulseaudio-under-the-hood/</link>
      <pubDate>Thu, 21 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://gavv.github.io/blog/pulseaudio-under-the-hood/</guid>
      <description>Table of contents
 Preface About PulseAudio High-level components Key abstractions D-Bus API C API Protocols and networking Device drivers Sound processing Sample cache Stream management Time management Power saving Automatic setup and routing Desktop integrations Compatibility layers Server internals Module list GUI tools Command line tools Configuration Portability Example setups Example clients and modules Critique  Preface I&amp;rsquo;m working on the Roc open-source project, a development kit for realtime streaming over an unreliable network.</description>
    </item>
    
    <item>
      <title>Using MiniSAPServer and MiniSAPListener for SAP/SDP</title>
      <link>http://gavv.github.io/blog/minisaplistener/</link>
      <pubDate>Fri, 09 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://gavv.github.io/blog/minisaplistener/</guid>
      <description>MiniSAPServer is a small program that periodically sends SAP/SDP messages, given a config file and destination address.
I&amp;rsquo;ve prepared a complementary MiniSAPListener program which listens for SAP/SDP messages, and prints them to stdout or passes to a shell command. The source code is mostly extracted from PulseAudio RTP receiver.
To send custom SAP/SDP messages, one should create two configuration files for MiniSAPServer, one with SAP configuration, and another with an SDP message.</description>
    </item>
    
    <item>
      <title>File locking in Linux</title>
      <link>http://gavv.github.io/blog/file-locks/</link>
      <pubDate>Fri, 29 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://gavv.github.io/blog/file-locks/</guid>
      <description>Table of contents
 Introduction Advisory locking  Common features Differing features File descriptors and i-nodes BSD locks (flock) POSIX record locks (fcntl) lockf function Open file description locks (fcntl) Emulating Open file description locks Command line tools  Mandatory locking  Introduction File locking is a mutual-exclusion mechanism for files. Linux supports two major kinds of file locks:
 advisory locks mandatory locks  Below we discuss all lock types available in POSIX and Linux and provide usage examples.</description>
    </item>
    
    <item>
      <title>Reusing UNIX domain socket (SO_REUSEADDR for AF_UNIX)</title>
      <link>http://gavv.github.io/blog/unix-socket-reuse/</link>
      <pubDate>Thu, 07 Jul 2016 00:00:01 +0000</pubDate>
      
      <guid>http://gavv.github.io/blog/unix-socket-reuse/</guid>
      <description>Unix domain sockets are a networkless version of Internet sockets.
They have several advantages:
 Unix domain sockets are files, so file-system permissions may be used for them when one end is closed (e.g. process exits), SIGPIPE is delivered to another end performance may be up to 2x better  See details here.
Lack of SO_REUSEADDR A socket file is created by bind(2) call. If the file already exists, EADDRINUSE is returned.</description>
    </item>
    
    <item>
      <title>Decoding and playing audio files in Linux</title>
      <link>http://gavv.github.io/blog/decode-play/</link>
      <pubDate>Thu, 07 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://gavv.github.io/blog/decode-play/</guid>
      <description>Table of contents
 Overview FFmpeg SoX ALSA (libasound) PulseAudio Other libraries Notes  Overview I was playing with various media libraries recently and have prepared several snippets demonstrating how one can decode and play an audio file in two separate steps.
The source code is available on GitHub here and there.
The following libraries are used:
 FFmpeg SoX ALSA (libasound) PulseAudio libsndfile  Each snippet is a small program.</description>
    </item>
    
    <item>
      <title>Detecting USB devices with libudev</title>
      <link>http://gavv.github.io/blog/libudev-usb/</link>
      <pubDate>Tue, 05 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://gavv.github.io/blog/libudev-usb/</guid>
      <description>Below you can find code snippets that match USB devices using libudev.
A good tutorial is available here: libudev and Sysfs Tutorial.
Listing and monitoring USB devices The snippet first prints all detected USB devices, and then enters monitoring mode and prints USB devices when they are inserted or removed.
Source code on GitHub: udev_monitor_usb.c
Example output:
$ ./a.out usb usb_device exists 1d6b:0001 /dev/bus/usb/002/001 usb usb_device exists 046d:c05b /dev/bus/usb/002/002 usb usb_device exists 1d6b:0001 /dev/bus/usb/003/001 usb usb_device exists 1d6b:0001 /dev/bus/usb/004/001 usb usb_device exists 1d6b:0001 /dev/bus/usb/005/001 usb usb_device exists 1d6b:0002 /dev/bus/usb/001/001 usb usb_device add 8564:1000 /dev/bus/usb/001/026 usb usb_device remove 0000:0000 /dev/bus/usb/001/026 ^C  Listing USB storage devices The snippet prints detected USB storage devices.</description>
    </item>
    
  </channel>
</rss>
